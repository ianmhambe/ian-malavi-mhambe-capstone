# AWS EKS Secrets
# ==========================================
# DO NOT COMMIT REAL CREDENTIALS TO GIT!
# ==========================================
#
# For production, use one of these approaches:
#
# Option 1: AWS Secrets Manager with External Secrets Operator
#   - Install External Secrets Operator in your cluster
#   - Create an ExternalSecret that references AWS Secrets Manager
#
# Option 2: Create secrets via kubectl (recommended for initial setup):
#   kubectl create secret generic caresync-secrets \
#     --namespace ian-malavi-mhambe \
#     --from-literal=DATABASE_URL="mysql://USER:PASS@RDS_ENDPOINT:3306/DATABASE" \
#     --from-literal=JWT_SECRET="$(openssl rand -base64 64)" \
#     --from-literal=JWT_REFRESH_SECRET="$(openssl rand -base64 64)"
#
# Option 3: Use Sealed Secrets (see k8s/sealed-secrets.yaml)
#
# This file is a TEMPLATE ONLY - replace placeholders before applying
---
apiVersion: v1
kind: Secret
metadata:
  name: caresync-secrets
  namespace: ian-malavi-mhambe
  labels:
    app.kubernetes.io/name: caresync
    app.kubernetes.io/component: secrets
type: Opaque
stringData:
  # IMPORTANT: These are PLACEHOLDER values only!
  # Replace with actual values using kubectl create secret or external secrets
  # Format for MySQL/MariaDB: mysql://USERNAME:PASSWORD@RDS_ENDPOINT:3306/DATABASE_NAME
  DATABASE_URL: "mysql://USERNAME:PASSWORD@RDS_ENDPOINT:3306/DATABASE_NAME"
  # Generate strong secrets: openssl rand -base64 64
  JWT_SECRET: "REPLACE_WITH_STRONG_SECRET_KEY_MIN_32_CHARS"
  JWT_REFRESH_SECRET: "REPLACE_WITH_ANOTHER_STRONG_SECRET_KEY"
